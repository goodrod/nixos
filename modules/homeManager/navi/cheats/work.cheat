% (work)
# (pull/fastforward)            Pull latest version of current branch on each repo in directory
for dir in */.git; do
  repo="${dir%/.git}"
  if [[ ! "$repo" =~ ^misc ]]; then
    cd "$repo" || continue
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    # Pull latest changes (fast forward only) on the current branch
    echo -e "\033[1;34mPulling latest changes for $repo on branch $current_branch\033[0m"
    git pull --ff-only origin "$current_branch"

    cd - > /dev/null
  fi
done

# (diff)                        Output diff of all repos
changes_found=false
for dir in */.git; do
  repo="${dir%/.git}"
  if [[ ! "$repo" =~ ^misc ]]; then
    cd "$repo" || continue
    changes=$(git status --short)
    if [[ -n "$changes" ]]; then
      changes_found=true
      echo -e "\033[1;34mRepository: $repo\033[0m"
      
      untracked=$(echo "$changes" | grep '??' | sed 's/?? /\033[1;32m  &\033[0m/')
      modified=$(echo "$changes" | grep '^[ M]' | sed 's/^.[ ]*/  \033[1;31m&\033[0m/')

      if [[ -n "$untracked" ]]; then
        echo -e "\033[1;33mUntracked:\033[0m"
        echo "$untracked"
      fi

      if [[ -n "$modified" ]]; then
        echo -e "\033[1;31mModified:\033[0m"
        echo "$modified"
        echo -e "\033[1;35mDiff:\033[0m"
        GIT_PAGER=cat git diff  # Forces direct output, bypassing less
      fi
      
      echo
    fi
    cd - > /dev/null || exit
  fi
done

if [[ "$changes_found" == false ]]; then
  echo -e "\033[1;32mNo changes found in any repository.\033[0m"
fi


# (tag/push)                    Tag and push all repos that are on a certain branch

read -p "Enter branch name to check: " branch_name
read -p "Enter tag name to apply: " tag_name

for dir in */.git; do
  repo="${dir%/.git}"
  if [[ ! "$repo" =~ ^misc ]]; then
    cd "$repo" || continue
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    if [[ "$current_branch" == "$branch_name" ]]; then
      echo -e "\033[1;34mTagging $repo on branch $branch_name with tag $tag_name\033[0m"
      git tag "$tag_name"
      git push origin "$tag_name"
      echo -e "\033[1;32mPushed tag $tag_name for $repo\033[0m"
    else
      echo -e "\033[1;33mSkipping $repo (on branch $current_branch, not $branch_name)\033[0m"
    fi

    cd - > /dev/null
  fi
done


# (checkout/release)            Checkout release branches for all repos in directory 
for repo in *; do [ -d "$repo/.git" ] && git -C "$repo" fetch --quiet && if git -C "$repo" branch -r | grep -q "origin/release/<release-version>"; then git -C "$repo" checkout release/<release-version> --quiet && git -C "$repo" pull --quiet && echo -e "\e[32mChecked out 'release/<release-version>' in $repo\e[0m" || echo -e "\e[31mFailed to checkout 'release/<release-version>' in $repo\e[0m"; else echo -e "\e[31m'release/<release-version>' branch not found in $repo\e[0m"; fi; done

# (commit/push)                 Commit and push changes in all git repos in current directory
read -p "Enter commit message: " commit_message

for dir in */.git; do
  repo="${dir%/.git}"
  if [[ ! "$repo" =~ ^misc ]]; then
    cd "$repo" || continue
    changes=$(git status --short)

    if [[ -n "$changes" ]]; then
      echo -e "\033[1;34mUpdating repository: $repo\033[0m"
      git add .
      git commit -m "$commit_message" > /dev/null 2>&1
      git push > /dev/null 2>&1
      echo -e "\033[1;32mPushed changes to $repo\033[0m"
    else
      echo -e "\033[1;33mNo changes in $repo, skipping...\033[0m"
    fi

    cd - > /dev/null
  fi
done


# (forward)                     Do some port forward that is needed to connect to the minikube
ssh -N -L 8009:localhost:8001 Perseus@192.168.7.180

# (connect)                     Connect to the docker stage as persues
ssh 192.168.7.180 -l Perseus

# (create/release)              Create release branches
for repo in */.git; do repo_dir=$(dirname "$repo"); cd "$repo_dir"; base_branch=$(git rev-parse --verify development &>/dev/null && echo development || (git rev-parse --verify main &>/dev/null && echo main || echo master)); release_branch="release/<release-version>"; echo "In repository '$repo_dir': Will create branch '$release_branch' from '$base_branch' and push it to origin."; read -p "Do you want to proceed? (y/n): " confirm; [[ $confirm == [yY] ]] && git checkout "$base_branch" && git checkout -b "$release_branch" && git push -u origin "$release_branch" && echo "Branch '$release_branch' created and pushed to remote in repository '$repo_dir'."; cd -; done


# (commit/push/WIP)             Commit changes with a "WIP" message and push to the current feature branch
for dir in */.git; do
  repo="${dir%/.git}"
  
  # Ensure that the directory exists and is a valid git repo
  if [[ -d "$repo" && -d "$dir" && ! "$repo" =~ ^misc ]]; then
    changes=$(cd "$repo" && git status --short)
    if [[ -n "$changes" ]]; then
      echo -e "\033[1;34mRepository: $repo\033[0m"
      
      # Commit changes with WIP message
      cd "$repo"
      git add .
      git commit -m "WIP"
      
      # Check the current branch
      current_branch=$(git rev-parse --abbrev-ref HEAD)

      # Skip non-feature branches
      if [[ "$current_branch" != feature/* && "$current_branch" != bugfix/* && "$current_branch" != hotfix/* ]]; then
        echo -e "\033[1;33mCurrent branch '$current_branch' is not a feature branch, skipping push.\033[0m"
        cd -  # go back to parent directory toprocess the next repo
        continue
      fi

      # Push to current branch
      git push origin "$current_branch"
      
      echo -e "\033[1;32mCommitted and pushed to branch: $current_branch\033[0m"
      echo
      cd -  # go back to parent directory
    fi
  fi
done

# (summarize)                   Summarize git status of all repos in current directory
changes_found=false
for dir in */.git; do
  repo="${dir%/.git}"
  if [[ ! "$repo" =~ ^misc ]]; then
    changes=$(cd "$repo" && git status --short)
    if [[ -n "$changes" ]]; then
      changes_found=true
      echo -e "\033[1;34mRepository: $repo\033[0m"
      echo -e "\033[1;33mUntracked:\033[0m"
      echo "$changes" | grep '??' | sed 's/?? /\033[1;32m  &\033[0m/'
      echo -e "\033[1;31mModified:\033[0m"
      echo "$changes" | grep '^[ M]' | sed 's/^.[ ]*/  \033[1;31m&\033[0m/'
      echo
    fi
  fi
done

if [[ "$changes_found" == false ]]; then
  echo -e "\033[1;32mNo changes found in any repository.\033[0m"
fi

# (current/status)              Output current branch of all repos
bold_white='\033[1;37m'
blue='\033[1;34m'
green='\033[0;32m'
reset='\033[0m'
printf "${bold_white}%-20s %-20s${reset}\n" "Repository" "Status"

for repo in */.git; do
  repo_name=$(basename "$(dirname "$repo")")
  branch=$(git -C "$(dirname "$repo")" branch --show-current)
  printf "${blue}%-20s ${green}Checked out %s${reset}\n" "$repo_name" "$branch"
done

# (checkout)                    Chechout branch in all repos
COLOR_RESET='\033[0m'
COLOR_REPO='\033[1;34m'
COLOR_BRANCH='\033[1;32m'
COLOR_ERROR='\033[1;31m'
COLOR_SUCCESS='\033[1;33m'
COLOR_INFO='\033[1;37m'


prompt_for_input() {
    local prompt_message="$1"
    local valid_responses="$2"
    local user_input

    while true; do
        read -p "$prompt_message" user_input
        if [[ "$valid_responses" =~ (^|[[:space:]])"$user_input"($|[[:space:]]) ]]; then
            echo "$user_input"
            return
        fi
    done
}

if ls */.git &>/dev/null; then
    target_branch=""
    global_confirm=$(prompt_for_input "Do you want to check out the base branch (development/main/master) for all repositories? (y/n): " "y n Y N")

    if [[ $global_confirm == [nN] ]]; then
        read -p "Enter the branch you want to check out for all repositories: " target_branch
    fi



    echo -e "${COLOR_INFO}Repository           Status${COLOR_RESET}"

    for repo in */.git; do
        repo_dir=$(dirname "$repo")
        
        if ! cd "$repo_dir" &>/dev/null; then
            printf "${COLOR_ERROR}Error: Failed to enter directory '%s'${COLOR_RESET}\n" "$repo_dir"
            continue
        fi

        if [[ $global_confirm == [yY] ]]; then
            base_branch=$(git rev-parse --verify development &>/dev/null && echo development || 
                          (git rev-parse --verify main &>/dev/null && echo main || echo master))
            
            if git checkout "$base_branch" &>/dev/null; then
                if git pull &>/dev/null; then
                    printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Checked out ${base_branch}${COLOR_RESET}\n" "$repo_dir"
                else
                    printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Checked out ${base_branch}, ${COLOR_ERROR}Failed to pull${COLOR_RESET}\n" "$repo_dir"
                fi
            else
                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to check out ${base_branch}${COLOR_RESET}\n" "$repo_dir"
            fi
        else
            if git checkout "$target_branch" &>/dev/null; then
                if git pull &>/dev/null; then
                    printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Checked out ${target_branch}${COLOR_RESET}\n" "$repo_dir"
                else
                    printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Checked out ${target_branch}, ${COLOR_ERROR}Failed to pull${COLOR_RESET}\n" "$repo_dir"
                fi
            else
                if git checkout -b "$target_branch" &>/dev/null; then
                    if git pull &>/dev/null; then
                        printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Created and checked out ${target_branch}, updated${COLOR_RESET}\n" "$repo_dir"
                    else
                        printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Created and checked out ${target_branch}, ${COLOR_ERROR}Failed to pull${COLOR_RESET}\n" "$repo_dir"
                    fi
                else
                    printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to create branch ${target_branch}${COLOR_RESET}\n" "$repo_dir"
                    cd - &>/dev/null
                    continue
                fi
            fi
        fi

        if ! cd - &>/dev/null; then
            printf "${COLOR_ERROR}Error: Failed to return to the previous directory${COLOR_RESET}\n"
            continue
        fi
    done

    pwd

    echo -e "${COLOR_SUCCESS}Branch checkout completed for all repositories.${COLOR_RESET}"

    if [[ $global_confirm == [nN] && -n $target_branch ]]; then
        for repo in */.git; do
            repo_dir=$(dirname "$repo")
            if cd "$repo_dir"; then
                if git branch --list "$target_branch" &>/dev/null; then
                    if git show-ref --quiet "refs/remotes/origin/$target_branch"; then
		        cd - &> /dev/null
                        continue
                    else
                        read -p "Do you want to push '${target_branch}' to origin in repository '$repo_dir'? (y/n): " push_confirm
                        if [[ $push_confirm == [yY] ]]; then
                            if git push -u origin "$target_branch" &>/dev/null; then
                                printf "${COLOR_REPO}%-20s ${COLOR_SUCCESS}Pushed to origin${COLOR_RESET}\n" "$repo_dir"
                            else
                                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to push${COLOR_RESET}\n" "$repo_dir"
                            fi
                        else
			    base_branch=$(git rev-parse --verify development &>/dev/null && echo development || (git rev-parse --verify main &>/dev/null && echo main || echo master))
			    git checkout $base_branch &> /dev/null
                            if git branch -d "$target_branch" &> /dev/null ; then
                                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Local branch ${target_branch} deleted${COLOR_RESET}\n" "$repo_dir"
                            else
                                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to delete local branch ${target_branch}${COLOR_RESET}\n" "$repo_dir"
                            fi
                        fi
                    fi
                fi
                cd - &>/dev/null
            else
                printf "${COLOR_ERROR}Error: Failed to enter directory '%s'${COLOR_RESET}\n" "$repo_dir"
            fi
        done
    fi
else
    echo -e "${COLOR_INFO}No Git repositories found in the current directory.${COLOR_RESET}"
fi

# (rebase)                      Rebase current branch on main/master/development
#!/bin/bash
COLOR_RESET='\033[0m'
COLOR_REPO='\033[1;34m'
COLOR_BRANCH='\033[1;32m'
COLOR_ERROR='\033[1;31m'
COLOR_SUCCESS='\033[1;33m'
COLOR_INFO='\033[1;37m'

prompt_for_input() {
    local prompt_message="$1"
    local valid_responses="$2"
    local user_input

    while true; do
        read -p "$prompt_message" user_input
        if [[ "$valid_responses" =~ (^|[[:space:]])"$user_input"($|[[:space:]]) ]]; then
            echo "$user_input"
            return
        fi
    done
}

if ls */.git &>/dev/null; then
    target_branch=""
    global_confirm=$(prompt_for_input "Rebase current branch onto the base branch (development/main/master) for all repositories? (y/n): " "y n Y N")

    if [[ $global_confirm == [nN] ]]; then
        read -p "Enter the branch you want to rebase onto for all repositories: " target_branch
    fi

    echo -e "${COLOR_INFO}Repository           Status${COLOR_RESET}"

    for repo in */.git; do
        repo_dir=$(dirname "$repo")
        if ! cd "$repo_dir" &>/dev/null; then
            printf "${COLOR_ERROR}Error: Failed to enter directory '%s'${COLOR_RESET}\n" "$repo_dir"
            continue
        fi

        # Make sure we have the latest info
        git fetch &>/dev/null

        if [[ $global_confirm == [yY] ]]; then
            base_branch=$(git rev-parse --verify development &>/dev/null && echo development || \
                         (git rev-parse --verify main &>/dev/null && echo main || echo master))
            if git rebase "$base_branch" &>/dev/null; then
                printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Rebased onto %s${COLOR_RESET}\n" "$repo_dir" "$base_branch"
            else
                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to rebase onto %s${COLOR_RESET}\n" "$repo_dir" "$base_branch"
            fi
        else
            if git rebase "$target_branch" &>/dev/null; then
                printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Rebased onto %s${COLOR_RESET}\n" "$repo_dir" "$target_branch"
            else
                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to rebase onto %s${COLOR_RESET}\n" "$repo_dir" "$target_branch"
            fi
        fi

        if ! cd - &>/dev/null; then
            printf "${COLOR_ERROR}Error: Failed to return to the previous directory${COLOR_RESET}\n"
            continue
        fi
    done

    pwd
    echo -e "${COLOR_SUCCESS}Rebase operation completed for all repositories.${COLOR_RESET}"
else
    echo -e "${COLOR_INFO}No Git repositories found in the current directory.${COLOR_RESET}"
fi

# (edit/add)                    Edit Consultancy-Toolbox
nvim ~/Consultants-Toolbox/

# (fetch)                       Fetch everything from remote for all repos in dir
for dir in */.git; do
  repo="${dir%/.git}"
  if [[ ! "$repo" =~ ^misc ]]; then
    cd "$repo" || continue
    echo -e "\033[1;34mFetching all remotes for $repo\033[0m"
    git fetch --all --prune
    cd - > /dev/null
  fi
done

# (remove/delete)               Delete branch in all repos
read -rp "Branch to delete locally in all repos: " branch_to_delete

if [[ -z "$branch_to_delete" ]]; then
  echo "No branch specified. Exiting."
  exit 1
fi

for dir in */.git; do
  repo="${dir%/.git}"
  if [[ ! "$repo" =~ ^misc ]]; then
    cd "$repo" || continue
    if git show-ref --verify --quiet "refs/heads/$branch_to_delete"; then
      echo -e "\033[1;31mDeleting branch $branch_to_delete in $repo\033[0m"
      git branch -D "$branch_to_delete"
    else
      echo -e "\033[0;33mBranch $branch_to_delete not found in $repo\033[0m"
    fi
    cd - > /dev/null
  fi
done
