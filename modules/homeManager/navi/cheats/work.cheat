% (work)
# (checkout/release)            Checkout release branches for all repos in directory 
for repo in *; do [ -d "$repo/.git" ] && git -C "$repo" fetch --quiet && if git -C "$repo" branch -r | grep -q "origin/release/<release-version>"; then git -C "$repo" checkout release/<release-version> --quiet && git -C "$repo" pull --quiet && echo -e "\e[32mChecked out 'release/<release-version>' in $repo\e[0m" || echo -e "\e[31mFailed to checkout 'release/<release-version>' in $repo\e[0m"; else echo -e "\e[31m'release/<release-version>' branch not found in $repo\e[0m"; fi; done

# (forward)                     Do some port forward that is needed to connect to the minikube
ssh -N -L 8009:localhost:8001 Perseus@192.168.7.180

# (connect)                     Connect to the docker stage as persues
ssh 192.168.7.180 -l Perseus

# (create/release)              Create release branches
for repo in */.git; do repo_dir=$(dirname "$repo"); cd "$repo_dir"; base_branch=$(git rev-parse --verify development &>/dev/null && echo development || (git rev-parse --verify main &>/dev/null && echo main || echo master)); release_branch="release/<release-version>"; echo "In repository '$repo_dir': Will create branch '$release_branch' from '$base_branch' and push it to origin."; read -p "Do you want to proceed? (y/n): " confirm; [[ $confirm == [yY] ]] && git checkout "$base_branch" && git checkout -b "$release_branch" && git push -u origin "$release_branch" && echo "Branch '$release_branch' created and pushed to remote in repository '$repo_dir'."; cd -; done

# (summarize)                   Summarize git status of all repos in current directory
changes_found=false
for dir in */.git; do
  repo="${dir%/.git}"
  if [[ ! "$repo" =~ ^misc ]]; then
    changes=$(cd "$repo" && git status --short)
    if [[ -n "$changes" ]]; then
      changes_found=true
      echo -e "\033[1;34mRepository: $repo\033[0m"
      echo -e "\033[1;33mUntracked:\033[0m"
      echo "$changes" | grep '??' | sed 's/?? /\033[1;32m  &\033[0m/'
      echo -e "\033[1;31mModified:\033[0m"
      echo "$changes" | grep '^[ M]' | sed 's/^.[ ]*/  \033[1;31m&\033[0m/'
      echo
    fi
  fi
done

if [[ "$changes_found" == false ]]; then
  echo -e "\033[1;32mNo changes found in any repository.\033[0m"
fi

# (current/status)              Output current branch of all repos
bold_white='\033[1;37m'
blue='\033[1;34m'
green='\033[0;32m'
reset='\033[0m'
printf "${bold_white}%-20s %-20s${reset}\n" "Repository" "Status"

for repo in */.git; do
  repo_name=$(basename "$(dirname "$repo")")
  branch=$(git -C "$(dirname "$repo")" branch --show-current)
  printf "${blue}%-20s ${green}Checked out %s${reset}\n" "$repo_name" "$branch"
done

# (checkout)                    Chechout branch in all repos
COLOR_RESET='\033[0m'
COLOR_REPO='\033[1;34m'
COLOR_BRANCH='\033[1;32m'
COLOR_ERROR='\033[1;31m'
COLOR_SUCCESS='\033[1;33m'
COLOR_INFO='\033[1;37m'


prompt_for_input() {
    local prompt_message="$1"
    local valid_responses="$2"
    local user_input

    while true; do
        read -p "$prompt_message" user_input
        if [[ "$valid_responses" =~ (^|[[:space:]])"$user_input"($|[[:space:]]) ]]; then
            echo "$user_input"
            return
        fi
    done
}

if ls */.git &>/dev/null; then
    target_branch=""
    global_confirm=$(prompt_for_input "Do you want to check out the base branch (development/main/master) for all repositories? (y/n): " "y n Y N")

    if [[ $global_confirm == [nN] ]]; then
        read -p "Enter the branch you want to check out for all repositories: " target_branch
    fi



    echo -e "${COLOR_INFO}Repository           Status${COLOR_RESET}"

    for repo in */.git; do
        repo_dir=$(dirname "$repo")
        
        if ! cd "$repo_dir" &>/dev/null; then
            printf "${COLOR_ERROR}Error: Failed to enter directory '%s'${COLOR_RESET}\n" "$repo_dir"
            continue
        fi

        if [[ $global_confirm == [yY] ]]; then
            base_branch=$(git rev-parse --verify development &>/dev/null && echo development || 
                          (git rev-parse --verify main &>/dev/null && echo main || echo master))
            
            if git checkout "$base_branch" &>/dev/null; then
                if git pull &>/dev/null; then
                    printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Checked out ${base_branch}${COLOR_RESET}\n" "$repo_dir"
                else
                    printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Checked out ${base_branch}, ${COLOR_ERROR}Failed to pull${COLOR_RESET}\n" "$repo_dir"
                fi
            else
                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to check out ${base_branch}${COLOR_RESET}\n" "$repo_dir"
            fi
        else
            if git checkout "$target_branch" &>/dev/null; then
                if git pull &>/dev/null; then
                    printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Checked out ${target_branch}${COLOR_RESET}\n" "$repo_dir"
                else
                    printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Checked out ${target_branch}, ${COLOR_ERROR}Failed to pull${COLOR_RESET}\n" "$repo_dir"
                fi
            else
                if git checkout -b "$target_branch" &>/dev/null; then
                    if git pull &>/dev/null; then
                        printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Created and checked out ${target_branch}, updated${COLOR_RESET}\n" "$repo_dir"
                    else
                        printf "${COLOR_REPO}%-20s ${COLOR_BRANCH}Created and checked out ${target_branch}, ${COLOR_ERROR}Failed to pull${COLOR_RESET}\n" "$repo_dir"
                    fi
                else
                    printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to create branch ${target_branch}${COLOR_RESET}\n" "$repo_dir"
                    cd - &>/dev/null
                    continue
                fi
            fi
        fi

        if ! cd - &>/dev/null; then
            printf "${COLOR_ERROR}Error: Failed to return to the previous directory${COLOR_RESET}\n"
            continue
        fi
    done

    pwd

    echo -e "${COLOR_SUCCESS}Branch checkout completed for all repositories.${COLOR_RESET}"

    if [[ $global_confirm == [nN] && -n $target_branch ]]; then
        for repo in */.git; do
            repo_dir=$(dirname "$repo")
            if cd "$repo_dir"; then
                if git branch --list "$target_branch" &>/dev/null; then
                    if git show-ref --quiet "refs/remotes/origin/$target_branch"; then
		        cd - &> /dev/null
                        continue
                    else
                        read -p "Do you want to push '${target_branch}' to origin in repository '$repo_dir'? (y/n): " push_confirm
                        if [[ $push_confirm == [yY] ]]; then
                            if git push -u origin "$target_branch" &>/dev/null; then
                                printf "${COLOR_REPO}%-20s ${COLOR_SUCCESS}Pushed to origin${COLOR_RESET}\n" "$repo_dir"
                            else
                                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to push${COLOR_RESET}\n" "$repo_dir"
                            fi
                        else
			    base_branch=$(git rev-parse --verify development &>/dev/null && echo development || (git rev-parse --verify main &>/dev/null && echo main || echo master))
			    git checkout $base_branch &> /dev/null
                            if git branch -d "$target_branch" &> /dev/null ; then
                                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Local branch ${target_branch} deleted${COLOR_RESET}\n" "$repo_dir"
                            else
                                printf "${COLOR_REPO}%-20s ${COLOR_ERROR}Failed to delete local branch ${target_branch}${COLOR_RESET}\n" "$repo_dir"
                            fi
                        fi
                    fi
                fi
                cd - &>/dev/null
            else
                printf "${COLOR_ERROR}Error: Failed to enter directory '%s'${COLOR_RESET}\n" "$repo_dir"
            fi
        done
    fi
else
    echo -e "${COLOR_INFO}No Git repositories found in the current directory.${COLOR_RESET}"
fi

